Q-Group1-并发标记
{
    https://segmentfault.com/a/1190000021820577
    jvm怎么判断哪些对象应该回收呢?
    引用计数算法【缺：无法解决循环引用】、可达性分析算法【缺：停止用户线程】。

    怎么解决可达性算法的缺点？
    并发标记：让【GC线程】和【用户线程】同时运行；

    并发标记时会有什么问题？
    【浮动垃圾 - 活而死 - 标活收死】：标记时活着，后因【引用关系变化】导致死了，GC时不回收；  【尚可接受】
    【对象消失 - 死而活 - 标死收活】：标记时死了，后因【引用关系变化】导致活了，GC时被回收；  【不可接受】

    怎么解决对象消失现象
    *记录*变化的引用关系，【待扫描完成后，执行GC前】，先执行记录内容；
    【增量更新 - CMS】 ：记录insert，黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。【破坏：赋值器插入了一条或多条从黑色到白色对象的新引用】
    【原始快照 -  G1】 ：记录delete，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索。【破坏：赋值前删除了全部从灰色到该白色对象的直接或间接引用】

    这个记录是怎么实现的？
    【写屏障】可以看作虚拟机层面对【引用类型字段赋值】这个动作的AOP切面；
}

Q-Group1-跨带引用
{
    JVM怎么解决跨带引用问题的？
    年轻代：使用记忆集【卡表-bit数组】，通过写屏障【write barrier】维护卡表； - 把卡表里变脏【0变成1】的区域当成GC Root
    老年代：将整个年轻代当root
}

Java指针占多少字节？
32位占4字节，64位占8字节，开启压缩占4个字节。

为什么Java有GC还需要自己来关闭某些资源？
{
    作者：RednaxelaFX
    链接：https://www.zhihu.com/question/29265003/answer/43745406

    1、为什么要自己来关闭某些资源？
    因为GC只管内存不管别的资源。假如有内存以外的其它资源依附在Java对象上，如native memory（DirectByteBuffer）、file（FileInputStream）之类，那当然自己关闭最合适。
    为了“避免”程序员忘了自己释放那些资源，Java提供了finalizer、PhantomReference之类的机制来让程序员向GC注册“自动回调释放资源”的功能。
    但GC回调它们的时机不确定，所以只应该作为最后手段来使用，主要手段还是自己关闭最好。
    放个传送门：Java使用JNI调用C写的库时，使用malloc分配的内存是由谁来管理？
    - RednaxelaFX 的回答2、
    GC回收怎样算不确定？
    JVM规范其实只要求所有活着的对象要活着，并没有说死掉的对象要咋处理。甚至特意指明“不限制如何实现自动内存管理”。
    所以符合规范的JVM只要保证活对象是活的就好了，这是确定的。
    而不确定的是GC何时被唤起，死对象何时被收集，有finalizer的对象的finalizer何时被调用、被PhantomReference引用的对象何时通知PhantomReference之类。
    虽然执行时机不确定，但合理的GC实现通常会保证“死掉的对象终将被收集”，所以算不上有内存泄漏。
}

进程退出后占用的内存都去哪儿了?
{
    https://blog.csdn.net/github_37382319/article/details/108022124
    不论正常退出，还是异常退出：
    进程终结后所占用的内存将会被操作系统回收了；
    所谓回收，就是将进程所占用的内存空间标记为可用。
}

hotspot的安全点在哪儿？【重复代码】
{
    方法尾
    非计数循环尾【存在弊端】
}

OOM异常会导致JVM退出吗？
{
    https://zhuanlan.zhihu.com/p/269892810
    不会，退出了怎么生成dump？
    java虚拟机退出的条件是：虚拟机内不存在非守护线程。

    既然不会，为什么大部分程序OOM之后，JVM就挂了？
    【存疑：其他线程也会因为申请不到内存而OOM，导致所有非守护线程都OOM挂掉了，连锁反应导致整个JVM的退出】
    为何存疑：因为线程down了之后，其他线程申请内存时会触发GC，此时GC会回收OOM的线程持有的内存【经测】
}
