Q-Group1-并发标记
{
    https://segmentfault.com/a/1190000021820577
    jvm怎么判断哪些对象应该回收呢?
    引用计数算法【缺：无法解决循环引用】、可达性分析算法【缺：停止用户线程】。

    怎么解决可达性算法的缺点？
    并发标记：让【GC线程】和【用户线程】同时运行；

    并发标记时会有什么问题？
    【浮动垃圾 - 活而死 - 标活收死】：标记时活着，后因【引用关系变化】导致死了，GC时不回收；  【尚可接受】
    【对象消失 - 死而活 - 标死收活】：标记时死了，后因【引用关系变化】导致活了，GC时被回收；  【不可接受】

    怎么解决对象消失现象
    *记录*变化的引用关系，【待扫描完成后，执行GC前】，先执行记录内容；
    【增量更新 - CMS】 ：记录insert，黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。【破坏：赋值器插入了一条或多条从黑色到白色对象的新引用】
    【原始快照 -  G1】 ：记录delete，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索。【破坏：赋值前删除了全部从灰色到该白色对象的直接或间接引用】

    这个记录是怎么实现的？
    【写屏障】可以看作虚拟机层面对【引用类型字段赋值】这个动作的AOP切面；
}

Q-Group1-跨带引用
{
    JVM怎么解决跨带引用问题的？
    年轻代：使用记忆集【卡表-bit数组】，通过写屏障【write barrier】维护卡表； - 把卡表里变脏【0变成1】的区域当成GC Root
    老年代：将整个年轻代当root

}
