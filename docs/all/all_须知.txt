【一个原则：证明不了的不看  -- 说的天花乱坠，我看不见有什么用！】
【一个原则：自己得闭环】
【查看使用的是什么GC ： java -XX:+PrintCommandLineFlags -version】
【JVM内存管理 - http://www.cnblogs.com/zuoxiaolong/】

【对象消失：实际上是用户线程破坏了三色标记，使得黑直接指向白，这是三色标记不允许的，却是在并发标记下确实可能存在的】
【须知 - 并发标记】
{
    ①可达性分析算法是需要一个理论上的前提的：该算法的全过程都需要基于一个能保障一致性的快照中才能够分析，这意味着必须全程冻结用户线程的运行。
    ②【标记】阶段是所有使用可达性分析算法的垃圾回收器都有的阶段
    {
        G1中通过 【2 * bitMap】来标记
    }
    ③遍历GCRoot【根节点枚举】，在OopMap的加持下很快；沿着GCRoot遍历对象图【添加标记】，很慢；
    ④不采取措施的情况：用户线程与GC线程并行，便会产生【浮动垃圾】与【对象消失】，根本原因是【引用关系变化】
}

1.我们所看到的对象图是从上帝视角来观看，而作为对象本身是对自己的【是否有根|是否被标记】无感知的；
2.用户线程和GC线程是共同线程并发的

【原始快照一些规律】
{
    {
        可以把preBitmap和nextBitmap视作对象，PrevTAMS和NextTAMS视作前面两个集合的length；
        PreTAMS = preBitmap.size();【方便记忆】
    }

    nextBitmap【init申请空置空间 & Clean归零】
    prevBitmap【Clean使用】

}

GC调优的最终目的：高吞低延
吞吐量【程序CPU占用率】：应用程序线程用时占程序总用时的比例。 例如，吞吐量99/100意味着100秒的程序执行时间应用程序线程运行了99秒

