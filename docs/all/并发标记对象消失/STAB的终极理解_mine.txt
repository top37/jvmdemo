参考：R大STAB.jpg

让对象消失，和解决对象消失是两件事情，思考的时候不要弄混了。
在考虑对象消失的时候不要想解决方案；
我曾经陷入的颜色陷阱；

GC线程 - 标记黑白灰；
用户线程 - 引用变更；

【解决方案】
全对象记录【不论黑白灰，只要有引用删除就记录】
时间段获取【获取GC区间和用户区间重合的记录集】
解决方案：把旧的引用所指向的对象变成非白的【以旧的引用为根重新扫描】，最多产生点浮动垃圾。

Time：
server start----------'----'-----------------  删除记录总集：JVM取两个'|'之间的记录集：【'----'】
server start----------|----|-----------------  用户进程："|"表示STW，第一个为遍历根节点时【safepoint - enumroot】，第二个为重新标记时【safepoint - remark】
          GC           ----                    并发标记阶段

以下是我错误的理解方式得到的正确的推论【恰好说明我跟原作者考虑的也差不多】：
一句一句去理解
'黑'肯定是GC线程标记过的，且不会回头标它了，但是'黑'自己无感知，此时执行用户代码也在执行，该'黑'引用了【对象链上】的某一'白'；【不是对象链上的也引用不到】
原本，只要在链上，迟早会被扫到，黑指向该白，只要原来的引用还在，也不会有什么问题；
但是，黑指向该白后，【该白】原本的src【灰|白】断开了引用的话：
{
    如果src是灰的，做记录；【做记录的时候，若'该白'变色了，皆大欢喜，不用去管了；若'该白'没变，则就成为了后续通过记录，将'该白'变色】
    如果src是白的，做记录：
    {
        能变灰，做记录【做记录的时候，若'该白'变色了，皆大欢喜，不用去管了；若'该白'没变，后续通过记录，将'该白'变色】
        不能变灰【断链了，src白本身也是个垃圾】,也要做记录！【不为别的，黑引用了'该白'，src白可以去死，'该白'却是要活着的】
    }
    如果src是黑色的，....src怎么可能是黑色的【src黑，'该白'不可能为白】
}
恍然大悟：我狭隘了，记录的是【所有】删除记录。

【对象消失】
浮动垃圾是被允许的，对象消失是不可接受的；针对对象消失现象，威尔逊有一篇《论文》提出产生【对象消失现象】的【充分必要条件】：
一个【标记周期 - GC周期】内：
①赋值器【用户线程】 黑指白
②赋值器【用户线程】 【该白】失去所有能从【灰】到达它的引用路径(直接或间接) | 换句话，在【灰】扫到【该白】之前切断引用；
解析：【都说wilson，我就是没找到原论文是在哪儿描述的，上面的条件②是R大说的】
{
    目的：产生对象消失现象
    前提：三色标记中，正常情况下，不可能出现黑直接指向【引用】白，一定会有灰色过度；
    【对象消失，实际上是用户线程破坏了三色标记】
    Q：为什么②不说所有'黑|灰'到达它的引用？
    A：因为条件①就是'黑'；
    Q：②为什么是'灰'而不是'灰|白'？
    Q：因为断链了，src白本身也是个垃圾，自然影响不了'该白'的颜色；
    Q：②怎么理解？
    A：首先，成为灰的那一刻，在【该白】变色之前，就必须切断了，这样才会出现对象消失现象

        灰
        |
  root——黑——灰？——灰——白
        |
        灰
}
