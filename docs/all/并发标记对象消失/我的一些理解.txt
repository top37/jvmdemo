说说我的理解
JVM中的GC，有很多的论文支撑，理解这些论文的思想要比知道怎么实现的更为重要；
JVM规范可以看做是需求文档，具体实现现在首推HotSpot；
设计会出现什么问题，通过什么来解决，这种思维很重要；
eg：并发标记过程中会出现什么问题？
我们都知道，并发标记时GC过程中，用户线程也是工作的，所以就会出现两个不被期望的现象【相对STW】：
1.标记的同时，【生成新的对象】，这个对象是要被本轮的GC忽略的 - 【隐式存活】
2.标记的同时，【对象引用变更】，【浮动垃圾、对象消失】
浮动垃圾是被允许的，对象消失是不可接受的；针对对象消失现象，威尔逊有一篇《论文》提出产生【对象消失现象】的【充分必要条件】：
一个【标记周期 - GC周期】内：
①赋值器【用户线程】 黑指白
②赋值器【用户线程】 【该白】失去所有能从【灰】到达它的引用路径(直接或间接)

既然是充要条件，那么破坏一个就行了，根据以上理论基础：
CMS【增量更新】与G1【原始快照】各破坏一个；
手段用的是写屏障【write barrier】来【做记录】
不论黑白灰，只要有对象引用变化，就记录；

代码块中：
{
    c1 = new C();
    a.c = c1;
    c1 = null;

}
一句一句去理解
'黑'肯定是GC线程标记过的，且不会回头标它了，但是'黑'自己无感知，此时执行用户代码也在执行，该'黑'引用了【对象链上】的某一'白'；【不是对象链上的也引用不到】
原本，只要在链上，迟早会被扫到，黑指向该白，只要原来的引用还在，也不会有什么问题；
但是，黑指向该白后，【该白】原本的src【灰|白】断开了引用的话：
{
    如果src是灰的，做记录；【做记录的时候，若'该白'变色了，皆大欢喜，不用去管了；若'该白'没变，则就成为了后续通过记录，将'该白'变色】
    如果src是白的，做记录：
    {
        能变灰，做记录【做记录的时候，若'该白'变色了，皆大欢喜，不用去管了；若'该白'没变，后续通过记录，将'该白'变色】
        不能变灰【断链了，src白本身也是个垃圾】,也要做记录！【不为别的，黑引用了'该白'，src白可以去死，'该白'却是要活着的】
    }
    如果src是黑色的，....src怎么可能是黑色的【src黑，'该白'不可能为白】
}
我狭隘了，记录的是【所有】删除记录，但是不知道是不是只记录【从上下文来看，指的应该是一个标记周期内】
我的理解：当然了，记录就只管记录就行了，【不论你啥颜色，就记录】，理论上这种引用应该不是很多。






【该白】失去了所有'灰'和'能成为灰的白'的引用，但是现在的白不一定已
解决方式：记录 灰引白，白未变色时引用消失；