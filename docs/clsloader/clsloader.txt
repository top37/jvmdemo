双亲委派模型中，既然都是从bootstrap开始加载，为什么不直接从bootstrap类加载器开始遍历，而是要多出一个向上追溯的过程？
由于初始类加载器 & 定义类加载器的存在；
因为【起点不一，导致终点不一】
eg：
{
    若类的初始类加载器是ext_clsloader,则加载其内部的引用的类加载器绝不可能是Appclsloader；
}

在Java文件中，引用其它类，需要此Java文件比其引用类的起点低

当一个类被加载后，那么它（Java文件）所能访问的类（class）范围便确定了；
通俗的来说，就是：在Java文件中，引用其它类时，需要此Java文件的命名空间涵盖其所引用类的类加载器；


起点：一个类的起点是与生俱来的，并不是在main中产生的；（定义类加载器）
{
    ①这个“起点”是我自己定义的一个概念，含义是：一个类在被 ClassLoader 加载 时，该
    ClassLoader 在双亲委派链上的位置：
    {
        位置：BootStrap、Ext、App、UserDefine...
    }

    ②之所以说是“与生俱来的”，是因为：每个类的path不同；故而此类能访问的范围也就随之确定了：
    {
        范围：向上可见，向下不可见
        {
            eg：
            {
                Ext能访问BootStrap+Ext、不能访问App、UserDefine
                App能访问BootStrap+Ext+App、不能访问UserDefine
                ...
            }

        }
    }
}

命名空间：每个类加载器（实例）都有自己的命名空间
{
    命名空间由：该类加载器和其父加载器所加载的类组成；
    同一命名空间中，不会出现全限定名相同的两个类；
}

===========
概念：定义类加载器【决定起点】，初始类加载器
发起一个类的加载过程的类加载器和最终实际加载这个类的类加载器可能并不是一个。
前者称为初始类加载器，而后者称为定义类加载器。
两者的关联在于：一个 Java 类的定义类加载器是该类所导入的其它 Java 类的初始类加载器。
比如类 A 通过 import 导入了类 B，那么由类 A 的定义类加载器负责启动类 B 的加载过程。