【 首先，有必要说明一件事情 - GC Root是对象而不是ref 】
问题：GC Root是以下的哪个？
eg：Obj obj = new Obj();
答: Obj()对象；
解析：
相对于GC Roots对象集而言，obj 是一种身份的证明；
【换言之，通常来说】：
创建一个对象，对象会在堆上【开辟一块空间】，同时会将这块【所开辟空间的地址】作为【引用】

-------------------------------------------------------读懂上述再往下看------------------------------------------------------
Q：Obj obj = new Obj()：obj 存放在哪儿？
A：不确定，看看【作用域】是在哪儿；
若是方法中调用，则obj在栈中；
若是类的属性，则保存在方法区【理论上方法区也是堆】中；


Q：Obj obj = new Obj(); obj存放在哪儿？
A：根据上下文来确定。
比如
【栈中】
void func()
{
    Object obj = new Object();//这个obj在函数的栈里。
}
【堆中】
class Test
{
   private Object obj = new Object();//这个obj随对应的Test对象分配在堆里
}
对于方法中的局部变量的引用时存放在java运行时数据区的栈中，对于实例变量则是存放在java运行时数据区的堆中。

Q：若是在堆中，那么会被GC清理掉吗？
A：猜测 - 不会；
会不会被清理掉，取决于是否能找到根，需要看全局、执行时机；
可以作为根的，一共有四种：
①JNI【肯定不是】
②本地方法栈【时机，若是执行过了，肯定是会被回收的】
③static【全局，类属性】
④final【全局，类属性】

比如上面的例子，若是有某个类A：
A{
    final Test testRef = new Test();
}
则Test.obj不会被回收掉，因为能寻到根：GC ROOT ==> new Test()
