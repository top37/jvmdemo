https://bbs.csdn.net/topics/394620292?list=42514545

在算法比较章节里提到标记压缩(Mark-Compact)和复制(Copying)算法对引用修正的区别，
一般引用的修正发生在STW（Stop The World）期间，性能不好的系统会有停顿卡机的感觉就是因为这个。

“Mark-Compact 可能要先计算一次对象的目标地址，然后修正指针，然后再移动对象

其实说白了，就是系统类似于有个引用维护表(像可达性算法分析里提到的4种gc root和reference chain)，gc对象发生移动后，
一般对于堆区或静态区的引用，直接修改引用的指向(A->B，直接修改为A->C)；其他的引用，通过修改映射关系来间接改变指向(A->映射关系AB->B，修改为A->旧映射关系AB->新映射关系BC->C)。
为什么有些引用直接修改指向，有些引用修改映射关系？这应该也是一个性能平衡考虑，就好比新生代用复制gc算法，老生代用标记压缩gc算法一样，单纯的修改引用指向，
如果引用很多，比如多个引用同时指向同一个对象，遍历每个引用效率会很低，而如果只改变映射关系(旧地址到新地址映射)，那么改变一个地方，
所有的引用就都能同时改变为指向对象新地址，这样效率就大大提高。